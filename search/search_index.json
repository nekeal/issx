{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Issx","text":"<p>Documentation | Source Code | PyPI</p> <p>Tool for synchronizing issues between different services (e.g. GitHub, Gitlab Jira, etc.)</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Please note that <code>issx</code> is currently in the early stages of development. As such, it may be subject to significant changes and improvements. The links to PyPI and documentation provided above are placeholders and may not be operational yet. Users are encouraged to consult the GitHub repository for the latest updates and information on this project. We appreciate your interest and patience as we work to enhance <code>issx</code>.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#using-pip","title":"Using pip","text":"<pre><code>pip install issx\n</code></pre>"},{"location":"#using-pipx","title":"Using pipx","text":"<pre><code>pipx install issx\n</code></pre>"},{"location":"#basic-usage","title":"Basic usage","text":"<p>The basic functionality of <code>issx</code> is provided through the <code>issx</code> command-line interface (CLI). For a full list of available commands and options, please refer to the CLI reference.</p> <p>Warning</p> <p>The <code>issx</code> CLI requires a configuration file to be present in the working directory (<code>issx.toml</code>) or in <code>~/.config/issx.toml</code>. Refer to the Configuration file section for more information.</p>"},{"location":"#initializing-the-configuration-file","title":"Initializing the configuration file","text":"<p>There is a set of dedicated commands to initialize the configuration file and add instances and projects to it.</p>"},{"location":"#generate-a-new-instances-configuration","title":"Generate a new instance's configuration","text":"<p><pre><code>&gt; issx config generate-instance --instance gitlab-cloud\n\nEnter backend [gitlab/redmine]: gitlab\nEnter url: https://gitlab.com\nEnter token: token\n\n[instances.gitlab-cloud]\nbackend = 'gitlab'\nurl = 'https://gitlab.com'\ntoken = 'token'\n</code></pre> The output should be then copied to the Configuration file.</p>"},{"location":"#generate-a-new-projects-configuration","title":"Generate a new project's configuration","text":"<pre><code>&gt; issx config generate-project --project my-personal-project\nEnter instance: gitlab-cloud   # The name of the instance that is already configured\nEnter project: 11111111        # Identifier of the project characteristic for the instance's backend\n\n[projects.my-personal-project]\ninstance = 'gitlab-cloud'\nproject = '11111111'\n````\n\nThe output should be then copied to the [Configuration file](#configuration-file).\n\n### Copying issues\nIt allows to copy issues from one [configured](#configuration-file) project to another.\n\n```shell title=\"Copy an issue\"\nissx copy --source=&lt;project_name&gt; --target=&lt;project_name&gt; &lt;issue-id&gt;\n</code></pre> <p>where <code>source</code> and <code>target</code> are the names of the projects configured in the configuration file.</p> <p>Optionally you can customize the issue title and description by providing <code>--title-format/-T</code> and <code>--description-format/-D</code> flags. The format should be a string with placeholders for the issue fields (e.g. <code>{title}</code>, <code>{description}</code>, <code>{id}</code> etc.).</p> <p>Assigning the issue to the current user is also possible by providing <code>--assign-to-me/-M</code> flag.</p> Copy an issue with custom title and description assigning it to the current user<pre><code>issx copy --source=&lt;project_name&gt; --target=&lt;project_name&gt;  -T \"[copied] {title}\" -D \"Description: {description}\" -M &lt;issue-id&gt;\n</code></pre>"},{"location":"#verifying-authentication","title":"Verifying authentication","text":"<p>To validate the authentication with a newly configured instance, you can use command <code>issx auth-verify</code>: <pre><code>issx auth-verify --instance=&lt;instance_name&gt;\n</code></pre></p>"},{"location":"#configuration-file","title":"Configuration file","text":"<p>The configuration file can be either in the working directory (<code>issx.toml</code>) or in <code>~/.config/issx.toml</code>.</p> <p>It should have the following structure:</p> <pre><code>[instances.INSTANCE_NAME]\n    backend = \"gitlab\" / \"redmine\"\n    url = \"&lt;absolute url to the instance&gt;\"\n    token = \"&lt;API token used for authentication&gt;\"\n\n[projects.PROJECT_NAME]\n    instance = \"INSTANCE_NAME\"\n    project = \"&lt;project_id&gt;\"\n</code></pre> <p><code>Instances</code> section is used to configure the instances of the services (e.g. Gitlab, Redmine) that <code>issx</code> will interact with.</p> <p><code>Projects</code> section is used to configure the projects that <code>issx</code> will work with. Each project should be associated with an instance. <code>project</code> field should contain the project id available in the chosen instance (usually it is a number).</p>"},{"location":"#development","title":"Development","text":"<ul> <li>Clone this repository</li> <li>Requirements:</li> <li>Poetry</li> <li>Python 3.11+</li> <li>Create a virtual environment and install the dependencies</li> </ul> <pre><code>poetry install\n</code></pre> <ul> <li>Activate the virtual environment</li> </ul> <pre><code>poetry shell\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the docs directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github Pages page automatically as part each release.</p>"},{"location":"#releasing","title":"Releasing","text":"<p>Trigger the Draft release workflow (press Run workflow). This will update the changelog &amp; version and create a GitHub release which is in Draft state.</p> <p>Find the draft release from the GitHub releases and publish it. When  a release is published, it'll trigger release workflow which creates PyPI  release and deploys updated documentation.</p>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatting (<code>ruff format</code>), linters (e.g. <code>ruff</code> and <code>mypy</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This project was generated using the nekeal-python-package-cookiecutter template.</p>"},{"location":"api_docs/","title":"API documentation","text":""},{"location":"api_docs/#issx.cli","title":"cli","text":""},{"location":"api_docs/#issx.cli.auth_verify","title":"auth_verify","text":"<pre><code>auth_verify(instance_name: InstanceNameOption) -&gt; None\n</code></pre> <p>Verify the authentication to the instance.</p> Source code in <code>src/issx/cli.py</code> <pre><code>@app.command()\ndef auth_verify(instance_name: InstanceNameOption) -&gt; None:\n    \"\"\"Verify the authentication to the instance.\"\"\"\n    config = GenericConfigParser.from_file()\n    instance_manager = InstanceManager(config)\n    try:\n        instance = instance_manager.get_instance_client(instance_name)\n    except Exception as e:\n        console.print_exception()\n        console.print(\"Error when configuring client instance.\\n\", style=\"red\")\n        raise typer.Exit(1) from e\n    try:\n        username = asyncio.run(instance.auth())\n        if not username:\n            raise Exception(\"Authentication failed\")\n    except Exception as e:\n        console.print_exception()\n        console.print(\n            f\"Error when authenticating to {instance.get_instance_url()}\",\n            style=\"red\",\n        )\n        raise typer.Exit(1) from e\n    else:\n        console.print(\n            \"Authentication successful\",\n            f\"Instance: {instance.get_instance_url()}\",\n            f\"User: {username}\",\n            sep=\"\\n\",\n            style=\"green bold italic\",\n        )\n</code></pre>"},{"location":"api_docs/#issx.cli.copy","title":"copy","text":"<pre><code>copy(\n    source_project_name: Annotated[\n        str,\n        typer.Option(\n            --source,\n            help=\"Source project name configured in the config file\",\n        ),\n    ],\n    target_project_name: Annotated[\n        str,\n        typer.Option(\n            --target,\n            help=\"Target project name configured in the config file\",\n        ),\n    ],\n    issue_id: int,\n    title_format: Annotated[\n        str,\n        typer.Option(\n            --title - format,\n            -T,\n            help=\"Template of a new issue title. Can contain placeholders of the issue attributes: {id}, {title}, {description}, {web_url}, {reference}\",\n        ),\n    ] = \"{title}\",\n    description_format: Annotated[\n        str,\n        typer.Option(\n            --description - format,\n            -D,\n            help=\"Template of a new issue description. Can contain placeholders of the issue attributes: {id}, {title}, {description}, {web_url}, {reference}\",\n        ),\n    ] = \"{description}\",\n    allow_duplicates: Annotated[\n        bool,\n        typer.Option(\n            --allow - duplicates,\n            -A,\n            help=\"Allow for duplicate issues. If set, the command will return the first issue found with the same title. If no issues are found, a new issue will be created.\",\n        ),\n    ] = False,\n    assign_to_me: Annotated[\n        bool,\n        typer.Option(\n            --assign - to - me,\n            -M,\n            help=\"Whether to assign a newly created issue to the current user\",\n        ),\n    ] = False,\n) -&gt; int\n</code></pre> <p>Copy an issue from one project to another.</p> Source code in <code>src/issx/cli.py</code> <pre><code>@app.command()\ndef copy(\n    source_project_name: Annotated[\n        str,\n        typer.Option(\n            \"--source\", help=\"Source project name configured in the config file\"\n        ),\n    ],\n    target_project_name: Annotated[\n        str,\n        typer.Option(\n            \"--target\", help=\"Target project name configured in the config file\"\n        ),\n    ],\n    issue_id: int,\n    title_format: Annotated[\n        str,\n        typer.Option(\n            \"--title-format\",\n            \"-T\",\n            help=\"Template of a new issue title. Can contain placeholders of the\"\n            \" issue attributes: {id}, {title}, {description}, {web_url}, {reference}\",\n        ),\n    ] = \"{title}\",\n    description_format: Annotated[\n        str,\n        typer.Option(\n            \"--description-format\",\n            \"-D\",\n            help=\"Template of a new issue description. Can contain placeholders of the\"\n            \" issue attributes: {id}, {title}, {description}, {web_url}, {reference}\",\n        ),\n    ] = \"{description}\",\n    allow_duplicates: Annotated[\n        bool,\n        typer.Option(\n            \"--allow-duplicates\",\n            \"-A\",\n            help=\"Allow for duplicate issues. If set, the command will return the first\"\n            \" issue found with the same title. If no issues are found,\"\n            \" a new issue will be created.\",\n        ),\n    ] = False,\n    assign_to_me: Annotated[\n        bool,\n        typer.Option(\n            \"--assign-to-me\",\n            \"-M\",\n            help=\"Whether to assign a newly created issue to the current user\",\n        ),\n    ] = False,\n) -&gt; int:\n    \"\"\"Copy an issue from one project to another.\"\"\"\n\n    console.print(\n        Text.assemble(\n            f\"Copying issue {issue_id} from project \",\n            (source_project_name, \"bold magenta\"),\n            \" to project \",\n            (target_project_name, \"bold magenta\"),\n        )\n    )\n    config = GenericConfigParser.from_file()\n    instance_manager = InstanceManager(config)\n    try:\n        source_client = instance_manager.get_project_client(source_project_name)\n        target_client = instance_manager.get_project_client(target_project_name)\n    except Exception as e:\n        console.print_exception()\n        console.print(\"Error when configuring client instance.\\n\", style=\"red\")\n        raise typer.Exit(1) from e\n    new_issue = asyncio.run(\n        CopyIssueService(source_client, target_client).copy(\n            issue_id,\n            title_format,\n            description_format,\n            allow_duplicates=allow_duplicates,\n            assign_to_me=assign_to_me,\n        )\n    )\n    console.print(f\"Success!\\n{new_issue}\", style=\"green\")\n    return 0\n</code></pre>"},{"location":"api_docs/#issx.cli.generate_instance","title":"generate_instance","text":"<pre><code>generate_instance(\n    instance_name: Annotated[\n        str,\n        typer.Option(\n            --instance,\n            help=\"Name of then instance to generate new_config for. Only alphanumeric and -_ allowed\",\n        ),\n    ]\n) -&gt; None\n</code></pre> <p>Generate instance's new_config string</p> Source code in <code>src/issx/cli.py</code> <pre><code>@config_app.command()\ndef generate_instance(\n    instance_name: Annotated[\n        str,\n        typer.Option(\n            \"--instance\",\n            help=\"Name of then instance to generate new_config for.\"\n            \" Only alphanumeric and -_ allowed\",\n        ),\n    ],\n) -&gt; None:\n    \"\"\"Generate instance's new_config string\"\"\"\n\n    new_config = RichConfigReader().read(InstanceConfig)\n    console.print()\n    console.print(Text(new_config.as_toml(f\"instances.{instance_name}\")))\n\n    console.print(\n        \"\\nSuccess!\\nCopy the above config to your config file\", style=\"green\"\n    )\n</code></pre>"},{"location":"api_docs/#issx.cli.generate_project","title":"generate_project","text":"<pre><code>generate_project(\n    project_name: Annotated[\n        str,\n        typer.Option(\n            --project,\n            help=\"Name of then project to generate new_config for. Only alphanumeric and -_ allowed\",\n        ),\n    ]\n) -&gt; None\n</code></pre> <p>Generate project's new_config string. Instance must be already configured.</p> Source code in <code>src/issx/cli.py</code> <pre><code>@config_app.command()\ndef generate_project(\n    project_name: Annotated[\n        str,\n        typer.Option(\n            \"--project\",\n            help=\"Name of then project to generate new_config for.\"\n            \" Only alphanumeric and -_ allowed\",\n        ),\n    ],\n) -&gt; None:\n    \"\"\"Generate project's new_config string. Instance must be already configured.\"\"\"\n\n    new_config = RichConfigReader().read(ProjectFlatConfig)\n\n    console.print()\n    console.print(Text(new_config.as_toml(f\"projects.{project_name}\")))\n    config = GenericConfigParser.from_file()\n\n    try:\n        config.get_instance_config(new_config.instance)\n    except KeyError:\n        console.print(\n            f\"\\nWarning: instance [bold]{new_config.instance}[/bold] not found\"\n            f\" in the config file. If you want to generate a missing config run\"\n            f\" [bold]issx config generate-instance --instance {new_config.instance}\"\n            f\"[/bold] command\",\n            style=\"yellow\",\n        )\n\n    console.print(\n        \"\\nSuccess!\\nCopy the above config to your config file\", style=\"green\"\n    )\n</code></pre>"},{"location":"api_docs/#issx.cli_utils","title":"cli_utils","text":""},{"location":"api_docs/#issx.clients","title":"clients","text":""},{"location":"api_docs/#issx.clients.GitlabClient","title":"GitlabClient","text":"<p>             Bases: <code>IssueClientInterface</code>, <code>GitlabInstanceClient</code></p> <p>Gitlab client implementations</p> Source code in <code>src/issx/clients/gitlab.py</code> <pre><code>class GitlabClient(IssueClientInterface, GitlabInstanceClient):\n    \"\"\"Gitlab client implementations\"\"\"\n\n    def __init__(self, client: Gitlab, project_id: int):\n        self.project_id = project_id\n        self._project: Project | None = None\n        super().__init__(client)\n\n    async def create_issue(\n        self, title: str, description: str, assign_to_me: bool = False\n    ) -&gt; Issue:\n        project = await self._get_project()\n        issue: ProjectIssue = cast(\n            ProjectIssue,\n            project.issues.create(\n                {\n                    \"title\": title,\n                    \"description\": description,\n                    \"assignee_id\": self.get_user().id,\n                }\n            ),\n        )\n        return IssueMapper.issue_to_domain(issue)\n\n    async def get_issue(self, issue_id: int) -&gt; Issue:\n        issue: ProjectIssue = await self._get_issue(issue_id)\n        return IssueMapper.issue_to_domain(issue)\n\n    async def find_issues(self, title: str) -&gt; list[Issue]:\n        project = await self._get_project()\n        issues = cast(list[ProjectIssue], list(project.issues.list(search=title)))\n        return IssueMapper.issues_to_domain_list(issues)\n\n    async def _get_project(self) -&gt; Project:\n        if self._project is None:\n            try:\n                self._project = self.client.projects.get(self.project_id)\n            except GitlabGetError as e:\n                raise ProjectDoesNotExistError(\n                    f\"Project with id={self.project_id} does not exist\"\n                ) from e\n        return self._project\n\n    async def _get_issue(self, issue_id: int) -&gt; ProjectIssue:\n        project = await self._get_project()\n        try:\n            return project.issues.get(issue_id)\n        except GitlabGetError as e:\n            raise IssueDoesNotExistError(issue_id) from e\n\n    @classmethod\n    def from_config(\n        cls, instance_config: InstanceConfig, project_config: ProjectFlatConfig\n    ) -&gt; Self:\n        project_config = cls.project_config_class(**asdict(project_config))\n        return cls(\n            GitlabInstanceClient.instance_from_config(instance_config).client,\n            project_id=int(project_config.project),\n        )\n</code></pre>"},{"location":"api_docs/#issx.clients.RedmineClient","title":"RedmineClient","text":"<p>             Bases: <code>IssueClientInterface</code>, <code>RedmineInstanceClient</code></p> <p>Redmine client implementation</p> Source code in <code>src/issx/clients/redmine.py</code> <pre><code>class RedmineClient(IssueClientInterface, RedmineInstanceClient):\n    \"\"\"Redmine client implementation\"\"\"\n\n    def __init__(self, client: Redmine, project_id: int):  # type: ignore[no-any-unimported]\n        self._project_id = project_id\n        self._project: Project | None = None  # type: ignore[no-any-unimported]\n        super().__init__(client)\n\n    async def create_issue(\n        self, title: str, description: str, assign_to_me: bool = False\n    ) -&gt; Issue:\n        issue = self.client.issue.create(\n            project_id=(await self.get_project()).id,\n            subject=title,\n            description=description,\n            assigned_to_id=\"me\" if assign_to_me else None,\n        )\n        return RedmineIssueMapper.issue_to_domain(issue)\n\n    async def get_issue(self, issue_id: int) -&gt; Issue:\n        try:\n            issue = self.client.issue.get(issue_id)\n        except ResourceNotFoundError as e:\n            raise IssueDoesNotExistError(issue_id) from e\n        return RedmineIssueMapper.issue_to_domain(issue)\n\n    async def find_issues(self, title: str) -&gt; list[Issue]:\n        return RedmineIssueMapper.issues_to_domain_list(\n            self.client.issue.filter(\n                project_id=(await self.get_project()).id, subject=title\n            )\n        )\n\n    async def get_project(self) -&gt; Project:  # type: ignore[no-any-unimported]\n        if self._project is None:\n            try:\n                self._project = self.client.project.get(self._project_id)\n            except ResourceNotFoundError as e:\n                raise ProjectDoesNotExistError(\n                    f\"Project with id={self._project_id} does not exist\"\n                ) from e\n        return self._project\n\n    @classmethod\n    def from_config(\n        cls, instance_config: InstanceConfig, project_config: ProjectFlatConfig\n    ) -&gt; Self:\n        project_config = cls.project_config_class(**asdict(project_config))\n        return cls(\n            RedmineInstanceClient.instance_from_config(instance_config).client,\n            project_id=int(project_config.project),\n        )\n</code></pre>"},{"location":"api_docs/#issx.clients.gitlab","title":"gitlab","text":""},{"location":"api_docs/#issx.clients.gitlab.GitlabClient","title":"GitlabClient","text":"<p>             Bases: <code>IssueClientInterface</code>, <code>GitlabInstanceClient</code></p> <p>Gitlab client implementations</p> Source code in <code>src/issx/clients/gitlab.py</code> <pre><code>class GitlabClient(IssueClientInterface, GitlabInstanceClient):\n    \"\"\"Gitlab client implementations\"\"\"\n\n    def __init__(self, client: Gitlab, project_id: int):\n        self.project_id = project_id\n        self._project: Project | None = None\n        super().__init__(client)\n\n    async def create_issue(\n        self, title: str, description: str, assign_to_me: bool = False\n    ) -&gt; Issue:\n        project = await self._get_project()\n        issue: ProjectIssue = cast(\n            ProjectIssue,\n            project.issues.create(\n                {\n                    \"title\": title,\n                    \"description\": description,\n                    \"assignee_id\": self.get_user().id,\n                }\n            ),\n        )\n        return IssueMapper.issue_to_domain(issue)\n\n    async def get_issue(self, issue_id: int) -&gt; Issue:\n        issue: ProjectIssue = await self._get_issue(issue_id)\n        return IssueMapper.issue_to_domain(issue)\n\n    async def find_issues(self, title: str) -&gt; list[Issue]:\n        project = await self._get_project()\n        issues = cast(list[ProjectIssue], list(project.issues.list(search=title)))\n        return IssueMapper.issues_to_domain_list(issues)\n\n    async def _get_project(self) -&gt; Project:\n        if self._project is None:\n            try:\n                self._project = self.client.projects.get(self.project_id)\n            except GitlabGetError as e:\n                raise ProjectDoesNotExistError(\n                    f\"Project with id={self.project_id} does not exist\"\n                ) from e\n        return self._project\n\n    async def _get_issue(self, issue_id: int) -&gt; ProjectIssue:\n        project = await self._get_project()\n        try:\n            return project.issues.get(issue_id)\n        except GitlabGetError as e:\n            raise IssueDoesNotExistError(issue_id) from e\n\n    @classmethod\n    def from_config(\n        cls, instance_config: InstanceConfig, project_config: ProjectFlatConfig\n    ) -&gt; Self:\n        project_config = cls.project_config_class(**asdict(project_config))\n        return cls(\n            GitlabInstanceClient.instance_from_config(instance_config).client,\n            project_id=int(project_config.project),\n        )\n</code></pre>"},{"location":"api_docs/#issx.clients.gitlab.IssueMapper","title":"IssueMapper","text":"<p>Maps Gitlab API objects to domain objects</p> Source code in <code>src/issx/clients/gitlab.py</code> <pre><code>class IssueMapper:\n    \"\"\"\n    Maps Gitlab API objects to domain objects\n    \"\"\"\n\n    @classmethod\n    def issue_to_domain(cls, issue: ProjectIssue) -&gt; Issue:\n        return Issue(\n            id=issue.iid,\n            title=issue.title,\n            description=issue.description,\n            web_url=issue.web_url,\n            reference=issue.references[\"full\"],\n        )\n\n    @classmethod\n    def issues_to_domain_list(cls, issues: list[ProjectIssue]) -&gt; list[Issue]:\n        return [cls.issue_to_domain(issue) for issue in issues]\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces","title":"interfaces","text":""},{"location":"api_docs/#issx.clients.interfaces.InstanceClientInterface","title":"InstanceClientInterface","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for a client that interacts with an issue tracker instance</p> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>class InstanceClientInterface(abc.ABC):\n    \"\"\"\n    Interface for a client that interacts with an issue tracker instance\n    \"\"\"\n\n    instance_config_class: ClassVar[type[InstanceConfig]] = InstanceConfig\n\n    @abc.abstractmethod\n    async def auth(self) -&gt; str | None:\n        \"\"\"\n        Authenticate the client with the instance.\n        Raises an internal error if the authentication fails or returns None.\n        :return: The username of the authenticated user or None\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_instance_url(self) -&gt; str:\n        \"\"\"\n        :return: The URL of the instance\n        \"\"\"\n        pass\n\n    @classmethod\n    @abc.abstractmethod\n    def instance_from_config(cls, instance_config: InstanceConfig) -&gt; Self:\n        \"\"\"\n        Create an instance of the client from a configuration dictionary.\n        If required, the instance_config can be converted to an instance-specific\n        configuration according to the `instance_config_class` attribute of the client.\n\n        :param instance_config: The configuration object. Higher level code\n        should validate the configuration.\n        :return: An instance of the client\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces.InstanceClientInterface.auth","title":"auth  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>auth() -&gt; str | None\n</code></pre> <p>Authenticate the client with the instance. Raises an internal error if the authentication fails or returns None.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The username of the authenticated user or None</p> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def auth(self) -&gt; str | None:\n    \"\"\"\n    Authenticate the client with the instance.\n    Raises an internal error if the authentication fails or returns None.\n    :return: The username of the authenticated user or None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces.InstanceClientInterface.get_instance_url","title":"get_instance_url  <code>abstractmethod</code>","text":"<pre><code>get_instance_url() -&gt; str\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>The URL of the instance</p> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>@abc.abstractmethod\ndef get_instance_url(self) -&gt; str:\n    \"\"\"\n    :return: The URL of the instance\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces.InstanceClientInterface.instance_from_config","title":"instance_from_config  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>instance_from_config(\n    instance_config: InstanceConfig,\n) -&gt; Self\n</code></pre> <p>Create an instance of the client from a configuration dictionary. If required, the instance_config can be converted to an instance-specific configuration according to the <code>instance_config_class</code> attribute of the client.</p> <p>Parameters:</p> Name Type Description Default <code>instance_config</code> <code>InstanceConfig</code> <p>The configuration object. Higher level code should validate the configuration.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the client</p> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef instance_from_config(cls, instance_config: InstanceConfig) -&gt; Self:\n    \"\"\"\n    Create an instance of the client from a configuration dictionary.\n    If required, the instance_config can be converted to an instance-specific\n    configuration according to the `instance_config_class` attribute of the client.\n\n    :param instance_config: The configuration object. Higher level code\n    should validate the configuration.\n    :return: An instance of the client\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces.IssueClientInterface","title":"IssueClientInterface","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>class IssueClientInterface(abc.ABC):\n    project_config_class: ClassVar[type[ProjectFlatConfig]] = ProjectFlatConfig\n\n    @abc.abstractmethod\n    async def get_issue(self, issue_id: int) -&gt; Issue:\n        \"\"\"\n        Retrieve an issue by its ID.\n        Raises IssueDoesNotExistError if the issue does not exist.\n        :param issue_id: The ID of the issue\n        :return: Issue object\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def create_issue(\n        self, title: str, description: str, assign_to_me: bool = False\n    ) -&gt; Issue:\n        \"\"\"\n        Create a new issue.\n        :param title: The title of the issue\n        :param description: The description of the issue\n        :param assign_to_me: Assign the issue to the authenticated user\n        :return:\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def find_issues(self, title: str) -&gt; list[Issue]:\n        \"\"\"\n        Find issues by title using an exact match.\n        :param title: The title of the issue\n        :return: List of issues\n        \"\"\"\n        pass\n\n    @classmethod\n    @abc.abstractmethod\n    def from_config(\n        cls, instance_config: InstanceConfig, project_config: ProjectFlatConfig\n    ) -&gt; Self:\n        \"\"\"\n        Create an instance of the client from configuration classes.\n        If required, the project_config can be converted to a project-specific\n        configuration according to the `project_config_class` attribute of the client.\n\n        Args:\n            instance_config: InstanceConfig to configure the client to the instance\n            project_config: ProjectFlatConfig to configure client. This config can then\n            be converted to a project-specific config according to\n            the `project_config_class` attribute of the client.\n            to the particular project\n\n        Returns:\n            An instance of the client\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces.IssueClientInterface.create_issue","title":"create_issue  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_issue(\n    title: str, description: str, assign_to_me: bool = False\n) -&gt; Issue\n</code></pre> <p>Create a new issue.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the issue</p> required <code>description</code> <code>str</code> <p>The description of the issue</p> required <code>assign_to_me</code> <code>bool</code> <p>Assign the issue to the authenticated user</p> <code>False</code> <p>Returns:</p> Type Description <code>Issue</code> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def create_issue(\n    self, title: str, description: str, assign_to_me: bool = False\n) -&gt; Issue:\n    \"\"\"\n    Create a new issue.\n    :param title: The title of the issue\n    :param description: The description of the issue\n    :param assign_to_me: Assign the issue to the authenticated user\n    :return:\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces.IssueClientInterface.find_issues","title":"find_issues  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>find_issues(title: str) -&gt; list[Issue]\n</code></pre> <p>Find issues by title using an exact match.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the issue</p> required <p>Returns:</p> Type Description <code>list[Issue]</code> <p>List of issues</p> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def find_issues(self, title: str) -&gt; list[Issue]:\n    \"\"\"\n    Find issues by title using an exact match.\n    :param title: The title of the issue\n    :return: List of issues\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces.IssueClientInterface.from_config","title":"from_config  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_config(\n    instance_config: InstanceConfig,\n    project_config: ProjectFlatConfig,\n) -&gt; Self\n</code></pre> <p>Create an instance of the client from configuration classes. If required, the project_config can be converted to a project-specific configuration according to the <code>project_config_class</code> attribute of the client.</p> <p>Args:     instance_config: InstanceConfig to configure the client to the instance     project_config: ProjectFlatConfig to configure client. This config can then     be converted to a project-specific config according to     the <code>project_config_class</code> attribute of the client.     to the particular project</p> <p>Returns:     An instance of the client</p> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef from_config(\n    cls, instance_config: InstanceConfig, project_config: ProjectFlatConfig\n) -&gt; Self:\n    \"\"\"\n    Create an instance of the client from configuration classes.\n    If required, the project_config can be converted to a project-specific\n    configuration according to the `project_config_class` attribute of the client.\n\n    Args:\n        instance_config: InstanceConfig to configure the client to the instance\n        project_config: ProjectFlatConfig to configure client. This config can then\n        be converted to a project-specific config according to\n        the `project_config_class` attribute of the client.\n        to the particular project\n\n    Returns:\n        An instance of the client\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_docs/#issx.clients.interfaces.IssueClientInterface.get_issue","title":"get_issue  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_issue(issue_id: int) -&gt; Issue\n</code></pre> <p>Retrieve an issue by its ID. Raises IssueDoesNotExistError if the issue does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>issue_id</code> <code>int</code> <p>The ID of the issue</p> required <p>Returns:</p> Type Description <code>Issue</code> <p>Issue object</p> Source code in <code>src/issx/clients/interfaces.py</code> <pre><code>@abc.abstractmethod\nasync def get_issue(self, issue_id: int) -&gt; Issue:\n    \"\"\"\n    Retrieve an issue by its ID.\n    Raises IssueDoesNotExistError if the issue does not exist.\n    :param issue_id: The ID of the issue\n    :return: Issue object\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_docs/#issx.clients.redmine","title":"redmine","text":""},{"location":"api_docs/#issx.clients.redmine.RedmineClient","title":"RedmineClient","text":"<p>             Bases: <code>IssueClientInterface</code>, <code>RedmineInstanceClient</code></p> <p>Redmine client implementation</p> Source code in <code>src/issx/clients/redmine.py</code> <pre><code>class RedmineClient(IssueClientInterface, RedmineInstanceClient):\n    \"\"\"Redmine client implementation\"\"\"\n\n    def __init__(self, client: Redmine, project_id: int):  # type: ignore[no-any-unimported]\n        self._project_id = project_id\n        self._project: Project | None = None  # type: ignore[no-any-unimported]\n        super().__init__(client)\n\n    async def create_issue(\n        self, title: str, description: str, assign_to_me: bool = False\n    ) -&gt; Issue:\n        issue = self.client.issue.create(\n            project_id=(await self.get_project()).id,\n            subject=title,\n            description=description,\n            assigned_to_id=\"me\" if assign_to_me else None,\n        )\n        return RedmineIssueMapper.issue_to_domain(issue)\n\n    async def get_issue(self, issue_id: int) -&gt; Issue:\n        try:\n            issue = self.client.issue.get(issue_id)\n        except ResourceNotFoundError as e:\n            raise IssueDoesNotExistError(issue_id) from e\n        return RedmineIssueMapper.issue_to_domain(issue)\n\n    async def find_issues(self, title: str) -&gt; list[Issue]:\n        return RedmineIssueMapper.issues_to_domain_list(\n            self.client.issue.filter(\n                project_id=(await self.get_project()).id, subject=title\n            )\n        )\n\n    async def get_project(self) -&gt; Project:  # type: ignore[no-any-unimported]\n        if self._project is None:\n            try:\n                self._project = self.client.project.get(self._project_id)\n            except ResourceNotFoundError as e:\n                raise ProjectDoesNotExistError(\n                    f\"Project with id={self._project_id} does not exist\"\n                ) from e\n        return self._project\n\n    @classmethod\n    def from_config(\n        cls, instance_config: InstanceConfig, project_config: ProjectFlatConfig\n    ) -&gt; Self:\n        project_config = cls.project_config_class(**asdict(project_config))\n        return cls(\n            RedmineInstanceClient.instance_from_config(instance_config).client,\n            project_id=int(project_config.project),\n        )\n</code></pre>"},{"location":"api_docs/#issx.clients.redmine.RedmineIssueMapper","title":"RedmineIssueMapper","text":"<p>Maps Redmine API objects to domain objects</p> Source code in <code>src/issx/clients/redmine.py</code> <pre><code>class RedmineIssueMapper:\n    \"\"\"\n    Maps Redmine API objects to domain objects\n    \"\"\"\n\n    @classmethod\n    def issue_to_domain(cls, issue: RedmineIssue) -&gt; Issue:  # type: ignore[no-any-unimported]\n        return Issue(\n            id=issue.id,\n            title=issue.subject,\n            description=issue.description,\n            web_url=issue.url,\n            reference=issue.id,\n        )\n\n    @classmethod\n    def issues_to_domain_list(cls, issues: ResourceSet) -&gt; list[Issue]:  # type: ignore[no-any-unimported]\n        return [cls.issue_to_domain(issue) for issue in issues]\n</code></pre>"},{"location":"api_docs/#issx.domain","title":"domain","text":""},{"location":"api_docs/#issx.domain.config","title":"config","text":""},{"location":"api_docs/#issx.domain.config.BaseConfig","title":"BaseConfig","text":"<p>Base class for config classes. It contains a raw_config attribute that should store the raw dictionary that was used to create the object.</p> Source code in <code>src/issx/domain/config.py</code> <pre><code>@define(kw_only=True)\nclass BaseConfig:\n    \"\"\"\n    Base class for config classes. It contains a raw_config attribute\n    that should store the raw dictionary that was used to create the object.\n    \"\"\"\n\n    raw_config: dict = attr.ib(\n        validator=attr.validators.instance_of(dict),\n        factory=dict,\n    )\n\n    @classmethod\n    def get_meaningful_fields(cls) -&gt; Iterable[attr.Attribute]:\n        \"\"\"\n        Get all fields except the raw_config field.\n\n        Returns: Iterable of fields\n        \"\"\"\n        fields = attr.fields(cls)\n        return [field for field in fields if field != fields.raw_config]\n\n    def as_toml(self, key: str) -&gt; str:\n        \"\"\"\n        Convert the object to a TOML string.\n        Args:\n            key: Key to use for the TOML table\n\n        Returns: TOML string\n        \"\"\"\n        nl = \"\\n\"\n        header = f\"[{key}]\"\n        attributes = [\n            f\"{field.name} = {repr(getattr(self, field.name))}\"\n            for field in self.get_meaningful_fields()\n        ]\n        return f\"{header}\\n{nl.join(attributes)}\"\n</code></pre>"},{"location":"api_docs/#issx.domain.config.BaseConfig.as_toml","title":"as_toml","text":"<pre><code>as_toml(key: str) -&gt; str\n</code></pre> <p>Convert the object to a TOML string. Args:     key: Key to use for the TOML table</p> <p>Returns: TOML string</p> Source code in <code>src/issx/domain/config.py</code> <pre><code>def as_toml(self, key: str) -&gt; str:\n    \"\"\"\n    Convert the object to a TOML string.\n    Args:\n        key: Key to use for the TOML table\n\n    Returns: TOML string\n    \"\"\"\n    nl = \"\\n\"\n    header = f\"[{key}]\"\n    attributes = [\n        f\"{field.name} = {repr(getattr(self, field.name))}\"\n        for field in self.get_meaningful_fields()\n    ]\n    return f\"{header}\\n{nl.join(attributes)}\"\n</code></pre>"},{"location":"api_docs/#issx.domain.config.BaseConfig.get_meaningful_fields","title":"get_meaningful_fields  <code>classmethod</code>","text":"<pre><code>get_meaningful_fields() -&gt; Iterable[attr.Attribute]\n</code></pre> <p>Get all fields except the raw_config field.</p> <p>Returns: Iterable of fields</p> Source code in <code>src/issx/domain/config.py</code> <pre><code>@classmethod\ndef get_meaningful_fields(cls) -&gt; Iterable[attr.Attribute]:\n    \"\"\"\n    Get all fields except the raw_config field.\n\n    Returns: Iterable of fields\n    \"\"\"\n    fields = attr.fields(cls)\n    return [field for field in fields if field != fields.raw_config]\n</code></pre>"},{"location":"api_docs/#issx.instance_managers","title":"instance_managers","text":""},{"location":"api_docs/#issx.instance_managers.managers","title":"managers","text":""},{"location":"api_docs/#issx.instance_managers.managers.InstanceManager","title":"InstanceManager","text":"Source code in <code>src/issx/instance_managers/managers.py</code> <pre><code>class InstanceManager:\n    backends: dict[\n        SupportedBackend,\n        tuple[type[InstanceClientInterface], type[IssueClientInterface]],\n    ] = {}\n\n    def __init__(self, config: GenericConfigParser):\n        self.config = config\n\n    @classmethod\n    def register_backend(\n        cls,\n        backend: SupportedBackend,\n        instance_client_class: type[InstanceClientInterface],\n        project_client_class: type[IssueClientInterface],\n    ) -&gt; None:\n        cls.backends[backend] = (instance_client_class, project_client_class)\n\n    @classmethod\n    def clear_backends(cls) -&gt; None:\n        cls.backends.clear()\n\n    def get_instance_client(self, instance: str) -&gt; InstanceClientInterface:\n        \"\"\"\n        Get an instance client for a given instance name.\n\n        Converts the instance config to the appropriate config class\n         and creates an instance client.\n        Args:\n            instance: Instance name\n\n        Returns: Instance of an instance client\n        \"\"\"\n        instance_config = self.config.get_instance_config(instance)\n        client_class = self.backends[instance_config.backend][0]\n        instance_config = client_class.instance_config_class(\n            **instance_config.raw_config, raw_config=instance_config.raw_config\n        )\n        return client_class.instance_from_config(instance_config)\n\n    def get_project_client(self, project: str) -&gt; IssueClientInterface:\n        \"\"\"\n        Get a project client for a given project name.\n\n        Converts the project config to the appropriate config class\n        and creates a project client.\n        Args:\n            project: Project name\n\n        Returns: Instance of a project client\n\n        \"\"\"\n        project_config = self.config.get_project_config(project)\n        instance_config = self.config.get_instance_config(project_config.instance)\n        instance_client_class, project_client_class = self.backends[\n            instance_config.backend\n        ]\n        instance_config = instance_client_class.instance_config_class(\n            **instance_config.raw_config, raw_config=instance_config.raw_config\n        )\n        project_config = project_client_class.project_config_class(\n            **project_config.raw_config, raw_config=project_config.raw_config\n        )\n        return project_client_class.from_config(instance_config, project_config)\n</code></pre>"},{"location":"api_docs/#issx.instance_managers.managers.InstanceManager.get_instance_client","title":"get_instance_client","text":"<pre><code>get_instance_client(\n    instance: str,\n) -&gt; InstanceClientInterface\n</code></pre> <p>Get an instance client for a given instance name.</p> <p>Converts the instance config to the appropriate config class  and creates an instance client. Args:     instance: Instance name</p> <p>Returns: Instance of an instance client</p> Source code in <code>src/issx/instance_managers/managers.py</code> <pre><code>def get_instance_client(self, instance: str) -&gt; InstanceClientInterface:\n    \"\"\"\n    Get an instance client for a given instance name.\n\n    Converts the instance config to the appropriate config class\n     and creates an instance client.\n    Args:\n        instance: Instance name\n\n    Returns: Instance of an instance client\n    \"\"\"\n    instance_config = self.config.get_instance_config(instance)\n    client_class = self.backends[instance_config.backend][0]\n    instance_config = client_class.instance_config_class(\n        **instance_config.raw_config, raw_config=instance_config.raw_config\n    )\n    return client_class.instance_from_config(instance_config)\n</code></pre>"},{"location":"api_docs/#issx.instance_managers.managers.InstanceManager.get_project_client","title":"get_project_client","text":"<pre><code>get_project_client(project: str) -&gt; IssueClientInterface\n</code></pre> <p>Get a project client for a given project name.</p> <p>Converts the project config to the appropriate config class and creates a project client. Args:     project: Project name</p> <p>Returns: Instance of a project client</p> Source code in <code>src/issx/instance_managers/managers.py</code> <pre><code>def get_project_client(self, project: str) -&gt; IssueClientInterface:\n    \"\"\"\n    Get a project client for a given project name.\n\n    Converts the project config to the appropriate config class\n    and creates a project client.\n    Args:\n        project: Project name\n\n    Returns: Instance of a project client\n\n    \"\"\"\n    project_config = self.config.get_project_config(project)\n    instance_config = self.config.get_instance_config(project_config.instance)\n    instance_client_class, project_client_class = self.backends[\n        instance_config.backend\n    ]\n    instance_config = instance_client_class.instance_config_class(\n        **instance_config.raw_config, raw_config=instance_config.raw_config\n    )\n    project_config = project_client_class.project_config_class(\n        **project_config.raw_config, raw_config=project_config.raw_config\n    )\n    return project_client_class.from_config(instance_config, project_config)\n</code></pre>"},{"location":"api_docs/#issx.services","title":"services","text":""},{"location":"api_docs/#issx.services.CopyIssueService","title":"CopyIssueService","text":"Source code in <code>src/issx/services.py</code> <pre><code>class CopyIssueService:\n    def __init__(\n        self, source_client: IssueClientInterface, target_client: IssueClientInterface\n    ):\n        self.source_client = source_client\n        self.target_client = target_client\n\n    async def copy(\n        self,\n        issue_id: int,\n        title_format: str = \"{title}\",\n        description_format: str = \"{description}\",\n        allow_duplicates: bool = False,\n        assign_to_me: bool = False,\n    ) -&gt; Issue:\n        \"\"\"\n        Copy an issue from the source client to the target client optionally\n        applying a title and description format. If `allow_duplicates` is `False`,\n        the method will return a first issue found with the same title.\n\n        :param issue_id: The ID of the issue to copy\n        :param title_format: The format for the new issue title\n        :param description_format: The format for the new issue description\n        :param allow_duplicates: Whether to allow duplicate issues\n        :param assign_to_me: Whether to assign the new issue to the current user\n        :return: Newly created or existing issue in the target client\n        \"\"\"\n        source_issue = await self.source_client.get_issue(issue_id)\n        target_title = self._prepare_string(source_issue, title_format)\n        if not allow_duplicates and (\n            issues := await self.target_client.find_issues(target_title)\n        ):\n            return issues[0]\n        new_issue = await self.target_client.create_issue(\n            title=target_title,\n            description=self._prepare_string(source_issue, description_format),\n            assign_to_me=assign_to_me,\n        )\n        return new_issue\n\n    @staticmethod\n    def _prepare_string(issue: Issue, title_format: str) -&gt; str:\n        \"\"\"\n        :param issue: Issue object from which to create the new title\n        :param title_format: template string for the new title.\n        Can contain placeholders for the issue attributes:\n        {id}, {title}, {description}, {web_url}, {reference}\n        :return:\n        \"\"\"\n        return title_format.format(\n            id=issue.id,\n            title=issue.title,\n            description=issue.description,\n            web_url=issue.web_url,\n            reference=issue.reference,\n        )\n</code></pre>"},{"location":"api_docs/#issx.services.CopyIssueService.copy","title":"copy  <code>async</code>","text":"<pre><code>copy(\n    issue_id: int,\n    title_format: str = \"{title}\",\n    description_format: str = \"{description}\",\n    allow_duplicates: bool = False,\n    assign_to_me: bool = False,\n) -&gt; Issue\n</code></pre> <p>Copy an issue from the source client to the target client optionally applying a title and description format. If <code>allow_duplicates</code> is <code>False</code>, the method will return a first issue found with the same title.</p> <p>Parameters:</p> Name Type Description Default <code>issue_id</code> <code>int</code> <p>The ID of the issue to copy</p> required <code>title_format</code> <code>str</code> <p>The format for the new issue title</p> <code>'{title}'</code> <code>description_format</code> <code>str</code> <p>The format for the new issue description</p> <code>'{description}'</code> <code>allow_duplicates</code> <code>bool</code> <p>Whether to allow duplicate issues</p> <code>False</code> <code>assign_to_me</code> <code>bool</code> <p>Whether to assign the new issue to the current user</p> <code>False</code> <p>Returns:</p> Type Description <code>Issue</code> <p>Newly created or existing issue in the target client</p> Source code in <code>src/issx/services.py</code> <pre><code>async def copy(\n    self,\n    issue_id: int,\n    title_format: str = \"{title}\",\n    description_format: str = \"{description}\",\n    allow_duplicates: bool = False,\n    assign_to_me: bool = False,\n) -&gt; Issue:\n    \"\"\"\n    Copy an issue from the source client to the target client optionally\n    applying a title and description format. If `allow_duplicates` is `False`,\n    the method will return a first issue found with the same title.\n\n    :param issue_id: The ID of the issue to copy\n    :param title_format: The format for the new issue title\n    :param description_format: The format for the new issue description\n    :param allow_duplicates: Whether to allow duplicate issues\n    :param assign_to_me: Whether to assign the new issue to the current user\n    :return: Newly created or existing issue in the target client\n    \"\"\"\n    source_issue = await self.source_client.get_issue(issue_id)\n    target_title = self._prepare_string(source_issue, title_format)\n    if not allow_duplicates and (\n        issues := await self.target_client.find_issues(target_title)\n    ):\n        return issues[0]\n    new_issue = await self.target_client.create_issue(\n        title=target_title,\n        description=self._prepare_string(source_issue, description_format),\n        assign_to_me=assign_to_me,\n    )\n    return new_issue\n</code></pre>"},{"location":"backends/","title":"Supported Backends","text":"<p>Issx aims to provide a simple and efficient way to synchronize issues between different backends (e.g. GitHub, Gitlab, Jira, etc.).</p> <p>Supported and planned backends:</p> <ul> <li> Gitlab  - cloud and on premise instances</li> <li> Redmine - on premise instances</li> <li> Jira</li> <li> GitHub</li> <li> Bitbucket</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#054-2024-04-29","title":"0.5.4 - 2024-04-29","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix section of printed toml config in the wizard</li> </ul>"},{"location":"changelog/#053-2024-04-29","title":"0.5.3 - 2024-04-29","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix printing toml config in the wizard</li> </ul>"},{"location":"changelog/#052-2024-04-29","title":"0.5.2 - 2024-04-29","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix prompt for fetching variables in the wizard</li> </ul>"},{"location":"changelog/#051-2024-04-29","title":"0.5.1 - 2024-04-29","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fix wizard for generating configs for projects and instances</li> </ul>"},{"location":"changelog/#050-2024-04-29","title":"0.5.0 - 2024-04-29","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add tests for instance manager</li> <li>Add possibility to specify a config class per instance client</li> <li>Add wizard for generating configs for projects and instances</li> </ul>"},{"location":"changelog/#040-2024-04-21","title":"0.4.0 - 2024-04-21","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Tests for client interfaces of different backends</li> <li>Tests for generic config parser</li> <li>Import linter for checking a compliance with the layered architecture</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improve gh actions configuration</li> <li>Make use of <code>attrs</code> library for parsing config files</li> </ul>"},{"location":"changelog/#032-2024-04-18","title":"0.3.2 - 2024-04-18","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Improve documentation configuration</li> <li>CLI reference to the documentation</li> </ul>"},{"location":"changelog/#031-2024-04-17","title":"0.3.1 - 2024-04-17","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Help text for the <code>--assign-to-me</code> flag</li> </ul>"},{"location":"changelog/#030-2024-04-17","title":"0.3.0 - 2024-04-17","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Add possibility to assign issues to a current user when copying</li> </ul>"},{"location":"changelog/#020-2024-04-15","title":"0.2.0 - 2024-04-15","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Add method for finding issues by a title to the client interface</li> <li>Possibility to allow for duplicate issues when copying (based on title)</li> </ul>"},{"location":"changelog/#010-2024-04-14","title":"0.1.0 - 2024-04-14","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Add a first bunch of tests \ud83d\udd28</li> <li>Add possibility of specifying issue's title and description format when copying</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Move exception message directly to the exception class</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Gitlab client uses global issue id instead of internal one</li> </ul>"},{"location":"changelog/#004-2024-04-14","title":"0.0.4 - 2024-04-14","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Add config parser from toml files</li> <li>Add plugin based instance manager</li> <li>Make use of instance manager in auth-verify command</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Adjust permissions for gh actions</li> <li>Implementation of Redmine issue client interface</li> <li>Extend instance manager with possibility to initialize issue client</li> <li>Adapt copy command to work with any configured project</li> </ul>"},{"location":"changelog/#002-2024-04-01","title":"0.0.2 - 2024-04-01","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Implementation of Gitlab issue client interface</li> <li>Service for copying issues between projects</li> <li>CLI for copying issues and verifying auth configuration with Gitlab (b7eed84)</li> </ul>"},{"location":"cli_usage/","title":"<code>issx</code>","text":"<p>Usage:</p> <pre><code>$ issx [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--install-completion</code>: Install completion for the current shell.</li> <li><code>--show-completion</code>: Show completion for the current shell, to copy it or customize the installation.</li> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>auth-verify</code>: Verify the authentication to the instance.</li> <li><code>copy</code>: Copy an issue from one project to another.</li> </ul>"},{"location":"cli_usage/#issx-auth-verify","title":"<code>issx auth-verify</code>","text":"<p>Verify the authentication to the instance.</p> <p>Usage:</p> <pre><code>$ issx auth-verify [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--instance TEXT</code>: [required]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli_usage/#issx-copy","title":"<code>issx copy</code>","text":"<p>Copy an issue from one project to another.</p> <p>Usage:</p> <pre><code>$ issx copy [OPTIONS] ISSUE_ID\n</code></pre> <p>Arguments:</p> <ul> <li><code>ISSUE_ID</code>: [required]</li> </ul> <p>Options:</p> <ul> <li><code>--source TEXT</code>: Source project name configured in the config file  [required]</li> <li><code>--target TEXT</code>: Target project name configured in the config file  [required]</li> <li><code>-T, --title-format TEXT</code>: Template of a new issue title. Can contain placeholders of the issue attributes: {id}, {title}, {description}, {web_url}, {reference}  [default: {title}]</li> <li><code>-D, --description-format TEXT</code>: Template of a new issue description. Can contain placeholders of the issue attributes: {id}, {title}, {description}, {web_url}, {reference}  [default: {description}]</li> <li><code>-A, --allow-duplicates</code>: Allow for duplicate issues. If set, the command will return the first issue found with the same title. If no issues are found, a new issue will be created.</li> <li><code>-M, --assign-to-me</code>: Whether to assign a newly created issue to the current user</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"}]}